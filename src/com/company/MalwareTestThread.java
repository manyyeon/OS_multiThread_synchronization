package com.company;

import java.util.*;

class MalwareTestThread implements Runnable{
    public static int threadNum; // 스레드 총 개수
    public static boolean choosing[]; // 공유 choosing 배열 선언
    public static int number[]; // 공유 number 배열 선언
    int tid; // 이 스레드 id(tid)
    int countLetterNum = 0; // 스레드가 읽은 글자 개수
    MalwareTestSystem malwareTestSystem;
    public MalwareTestThread(int tid, MalwareTestSystem malwareTestSystem, int threadNum) {
        this.tid = tid;
        this.malwareTestSystem = malwareTestSystem;
        choosing = new boolean[threadNum];
        number = new int[threadNum];
        for(int i=0; i<threadNum; i++) {
            choosing[i] = false;
            number[i] = 0;
        }
    }
    @Override
    public void run() {
        synchronized (this) {
            // 스레드가 100글자를 읽을 때까지 cs에 들어갔다 나왔다 반복
            while (countLetterNum <= 100) {
                choosing[tid] = true; // 번호표를 받을 준비
                number[tid] = getMaxNumber(number) + 1; // 번호표 발급
                choosing[tid] = false; // 번호표를 받음

                for(int j=0; j<threadNum; j++) {
                    while(choosing[j]) {
                        // 다른 애들이 번호표 다 받을 때까지 대기
                    }
                    while((number[j] != 0) && isSmallerThanMe(j, tid)) {
                        // 이 스레드가 가장 작은 번호표를 가질 때까지 waiting
                        // 스레드 j가 번호표를 갖고 있고 스레드 j의 번호표가 이 스레드의 번호표보다 작거나
                        // 또는 번호표가 같을 경우 j가 tid보다 작다면 스레드 j가 종료할 때(number[j]=0)까지 대기
                    }
                }
                // critical section
                number[tid] = 0;
                // remaining section

//                try {
//                    Thread.sleep(new Random().nextInt(1000));
//                } catch (InterruptedException e) {
//                    e.printStackTrace();
//                }
            }
        }
    }

    // 번호표 최댓값 반환해주는 함수
    public int getMaxNumber(int [] number) {
        int maxNumber = 0;
        for(int i=0; i<number.length; i++) {
            if(number[i] > maxNumber) {
                maxNumber = number[i];
            }
        }
        return maxNumber;
    }

    public boolean isSmallerThanMe(int j, int tid) {
        // 다른 스레드의 번호표가 작은 경우
        // 현재 프로세스가 대기하도록 true 리턴
        if(number[j] < number[tid]) {
            return true;
        }
        // 다른 프로세스의 번호표가 큰 경우
        // while문의 busy waiting을 빠져 나오도록 false 리턴
        else if(number[j] > number[tid]) {
            return false;
        }
        // 번호표가 같은 번호인 경우
        // pid를 비교하여 이 스레드의 tid가 크면 true
        // 이 스레드의 tid가 작으면 false
        else {
            if(j < tid) {
                return true;
            } else if (j > tid) {
                return false;
            }
        }
        return false;
    }
}
