package com.company;

import com.sun.tools.jconsole.JConsoleContext;

import java.io.File;
import java.io.*;
import java.util.Random;
import java.util.concurrent.Semaphore;

// 악성코드 탐지 시스템
class MalwareTestSystem {
    public static final int TEST_CODE_NUM = 9;
    private Semaphore semaphore = new Semaphore(TEST_CODE_NUM,true); // 세마포어 객체 생성 (Counting Semaphore)
    Malware Spyware; // 악성코드 Spyware
    Malware Trojan; // 악성코드 Trojan
    TestObj [] testObjs = new TestObj [TEST_CODE_NUM]; // 검사할 파일 코드들


    public MalwareTestSystem() {
        // 검사할 텍스트 파일들 불러오기
        // testId는 파일 번호랑 같게 함
        for(int i=0; i<TEST_CODE_NUM; i++) {
            testObjs[i] = new TestObj(i+1);
        }
        // 악성코드 읽어오기
        Spyware = new Malware("Spyware");
        Trojan = new Malware("Trojan");
    }

    public void use(MalwareTestThread currentThread) {
        try {
            semaphore.acquire(); // 세마포어 시작
            System.out.println(currentThread.tid + "번 스레드 세마포어 시작");
            searchMalwareCode(currentThread); // 스레드가 세마포어 획득할 때마다 이 함수를 호출함
            Thread.sleep(new Random().nextInt(100));
            semaphore.release(); // 세마포어 종료
            System.out.println(currentThread.tid + "번 스레드 세마포어 종료");
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

    }
    public void searchMalwareCode(MalwareTestThread currentThread) {
        String subTestCodeSpyware;
        String subTestCodeTrojan;
        String subSpyware;
        String subTrojan;

        //TestObj currentTestObj = null; // 지금 검사 중인 test 코드

        // 어떤 test 파일 코드가 읽을 수 있는 상태인지 탐색
        for (int i = 0; i < TEST_CODE_NUM; i++) {
            // 파일을 아직 다 안읽었고 && 누가 읽는 중이 아니라면(안 잠겨있으면)
            if (testObjs[i].bookMarkIdx != (testObjs[i].testCodeLength) && testObjs[i].lock == false) {
                testObjs[i].lock = true; // lock을 잠근다
                currentThread.currentTestObj = testObjs[i]; // 현재 검사 중인 test 코드 설정
                System.out.println(currentThread.tid + "번 스레드가 " + "File" + currentThread.currentTestObj.testId + ".txt를 검사하기 시작합니다...");
                break;
            }
        }

        // 스레드가 100글자 읽을 때까지 반복
        while (currentThread.countLetterNum <= currentThread.MAX_AVAILABLE_READ_NUM) {
            // countLetterNum이 0~99일 때 악성코드 검사를 수행하고 마지막에 countLetterNum == 100이면 수행 종료하는 부분만 실행하고 끝
            // 100번 검사 끝난 이후에 반복문이 한 번 더 도는 거라 bookMarkIdx는 다음 스레드가 검사 시작할 인덱스가 됨
            // 스레드가 읽은 글자 수가 100개면 스레드 수행 종료
            if (currentThread.countLetterNum == currentThread.MAX_AVAILABLE_READ_NUM) {
                System.out.println(currentThread.tid + "의 현재 countLetterNum : " + currentThread.countLetterNum);
                System.out.println(currentThread.tid + "번 스레드가 " + "File" + currentThread.currentTestObj.testId + ".txt를 읽다가 100글자 한계를 마주했습니다.");
                System.out.println(currentThread.tid + "가 읽고 있던 File" + currentThread.currentTestObj.testId+ ".txt의 bookMarkIdx : " + currentThread.currentTestObj.bookMarkIdx + ", " +"이 파일의 전체 텍스트 길이 : " + currentThread.currentTestObj.testCodeLength);

                // 아직 파일에 읽을 글자들이 남아있다면
                if (currentThread.currentTestObj.bookMarkIdx != currentThread.currentTestObj.testCodeLength) {
                    System.out.println("아직 " + "File" + currentThread.currentTestObj.testId + ".txt에는 읽을 글자들이 남아있으므로 다른 스레드가 읽어줄 것입니다.");
                    // 다른 스레드가 파일을 읽을 수 있도록 lock을 풀어줌
                    currentThread.currentTestObj.lock = false;
                }
                currentThread.isTerminated = true;
                break;
            }

            // 파일을 다 읽었을 경우
            if (currentThread.currentTestObj.bookMarkIdx == currentThread.currentTestObj.testCodeLength) {
                //currentThread.isTerminated = true;
                System.out.println("File" + currentThread.currentTestObj.testId + ".txt를 다 읽었습니다." + currentThread.tid + "번 스레드가 마지막으로 읽었습니다.");
                System.out.println("File" + currentThread.currentTestObj.testId + ".txt의 길이 : " + currentThread.currentTestObj.testCodeLength + ", " + currentThread.currentTestObj.bookMarkIdx + "까지 해서 다 읽음");
                // 아직 다 안 읽은 파일이 존재하는지 검사
                boolean isExistFile = false;
                for (int i = 0; i < TEST_CODE_NUM; i++) {
                    if (testObjs[i].bookMarkIdx != (testObjs[i].testCodeLength)) {
                        isExistFile = true;
                    }
                }
                if(isExistFile == false) {
                    currentThread.isTerminated = true;
                }
                // 다 읽은 경우에도 lock을 굳이 풀어줘야 하는지....?!?!?!@?
                break; // 이 반복문을 나가고 만약에 아직 이 스레드가 100글자를 다 안읽었으면 세마포어를 다시 얻어서 읽을 수 있는 파일을 알아서 찾아서 들어갈거임
            }

            // 저번 검사에서 악성코드 일치한 게 끊겼을 때 그게 이어지는지 검사
            // 파일을 처음 검사하는 게 아니라서 북마크 인덱스가 0이 아님
            // 끊겼으면 nextTestStartIdx_spyware이 0이 아닌 다른 인덱스 값으로 설정되어있음
            if (currentThread.currentTestObj.bookMarkIdx != 0 && currentThread.currentTestObj.nextTestStartIdx_spyware != 0) {
                subSpyware = Spyware.code.substring(currentThread.currentTestObj.nextTestStartIdx_spyware);
                subTestCodeSpyware = currentThread.currentTestObj.testCode.substring(currentThread.currentTestObj.bookMarkIdx, currentThread.currentTestObj.bookMarkIdx + subSpyware.length());
                if (subTestCodeSpyware.equals(subSpyware)) {
                    System.out.println(currentThread.tid + "번 스레드가 " + "File" + currentThread.currentTestObj.testId + ".txt에서 Spyware를 찾았습니다.");
                    currentThread.currentTestObj.isFindSpyware = true;
                }else {
                    System.out.println(currentThread.tid + "번 스레드가 " + "File" + currentThread.currentTestObj.testId + ".txt에서 Spyware를 찾는 추가적인 검사를 진행하였지만 맞는 코드가 아니었습니다.");
                }
                // nextTestStartIdx_spyware 값이 0인지 아닌지로 끊긴 일치한 부분이 있는지를 판단하기 때문에 여기서 초기화를 해줘야 다음에도 판단이 가능
                currentThread.currentTestObj.nextTestStartIdx_spyware = 0;
            }

            // 스레드가 읽은 글자 수가 (100-악성코드 길이)인 부분까지는 통째로 검사
            if (currentThread.countLetterNum <= currentThread.MAX_AVAILABLE_READ_NUM - Spyware.codeLength) {
                System.out.println(currentThread.tid + "번 스레드의 countLetterNum : "+ currentThread.countLetterNum);
                System.out.println(currentThread.tid + "번 스레드가 검사 중인 " + "File" + currentThread.currentTestObj.testId + ".txt의 bookMarkIdx : " + currentThread.currentTestObj.bookMarkIdx);
                // 파일의 끝부분이라 IndexOutOfBound 에러를 막기 위해서 substring 자르는 범위를 bookMarkIdx부터 끝까지로 설정
                if(currentThread.currentTestObj.bookMarkIdx + Spyware.codeLength - 1 >= currentThread.currentTestObj.testCodeLength) {
                    System.out.println("파일의 끝부분");
                    subTestCodeSpyware = currentThread.currentTestObj.testCode.substring(currentThread.currentTestObj.bookMarkIdx);
                }
                // 파일 중간 부분이면 악성코드 길이만큼 자르면 됨
                else {
                    subTestCodeSpyware = currentThread.currentTestObj.testCode.substring(currentThread.currentTestObj.bookMarkIdx, currentThread.currentTestObj.bookMarkIdx + Spyware.codeLength);
                }
                //System.out.println(currentThread.tid + "번 스레드가 " + currentThread.currentTestObj.testId + ".txt를 통째로 자름 : " + subTestCodeSpyware);
                if (subTestCodeSpyware.equals(Spyware.code)) {
                    System.out.println(currentThread.tid + "번 스레드가 " + "File" + currentThread.currentTestObj.testId + ".txt에서 Spyware를 찾았습니다.");
                    currentThread.currentTestObj.isFindSpyware = true;
                }
            }

            // 끊기는 부분
            if (currentThread.countLetterNum > currentThread.MAX_AVAILABLE_READ_NUM - Spyware.codeLength) {
                System.out.println("끊기는 부분");
                System.out.println(currentThread.tid + "번 스레드의 countLetterNum : "+ currentThread.countLetterNum);
                System.out.println(currentThread.tid + "번 스레드가 검사 중인 " + "File" + currentThread.currentTestObj.testId + ".txt의 bookMarkIdx : " + currentThread.currentTestObj.bookMarkIdx);
                // 악성코드를 검사할 앞부분만 자름(스레드가 검사할 테스트 코드의 글자가 남은 개수만큼)
                subSpyware = Spyware.code.substring(0, currentThread.MAX_AVAILABLE_READ_NUM - currentThread.countLetterNum);
                // 파일의 끝부분이라 IndexOutOfBound 에러를 막기 위해서 substring 자르는 범위를 bookMarkIdx부터 끝까지로 설정
                if(currentThread.currentTestObj.bookMarkIdx + Spyware.codeLength - 1 >= currentThread.currentTestObj.testCodeLength) {
                    System.out.println("파일의 끝부분");
                    subTestCodeSpyware = currentThread.currentTestObj.testCode.substring(currentThread.currentTestObj.bookMarkIdx);
                }
                else {
                    // 잘라낸 부분 악성코드 길이만큼 검사할 테스트 코드도 자름
                    subTestCodeSpyware = currentThread.currentTestObj.testCode.substring(currentThread.currentTestObj.bookMarkIdx, currentThread.currentTestObj.bookMarkIdx + subSpyware.length());
                }
                if (subTestCodeSpyware.equals(subSpyware)) {
                    currentThread.currentTestObj.nextTestStartIdx_spyware = subSpyware.length();
                    System.out.println(currentThread.tid + "번 스레드가 " + "File" + currentThread.currentTestObj.testId + ".txt에서 Spyware의 일부분인" + subTestCodeSpyware + "를 찾았습니다. 추가적인 검사를 통해 판단할 수 있습니다.");
                }
            }

            currentThread.countLetterNum++; // 스레드가 읽은 글자 수 += 1
            currentThread.currentTestObj.bookMarkIdx++; // 파일의 북마크 인덱스 += 1
            //System.out.println(currentThread.tid + "번 스레드의 countLetterNum ++ -> "+ currentThread.countLetterNum);
            //System.out.println(currentThread.tid + "번 스레드가 검사 중인 " + "File" + currentThread.currentTestObj.testId + ".txt의 bookMarkIdx ++ -> " + currentThread.currentTestObj.bookMarkIdx);
        }
    }
}
