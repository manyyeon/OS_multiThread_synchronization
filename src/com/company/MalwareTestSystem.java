package com.company;

import java.io.File;
import java.io.*;

// 악성코드 탐지 시스템
class MalwareTestSystem {
    public static final int TEST_CODE_NUM = 9;
    File spywareFile = new File("./inputText/Malware/Spyware.txt");
    File trojanFile = new File("./inputText/Malware/Trojan.txt");
    String [] testCode = new String [TEST_CODE_NUM];
    int [] nextReadStartIdx = new int[TEST_CODE_NUM]; // 테스트 파일 읽을 때 어디부터 읽을지 알려주는 인덱스
    String spywareCode = "";
    String trojanCode = "";
    boolean [] findSpyware = new boolean[TEST_CODE_NUM]; // 악성코드 찾았는지 판단해주는 변수
    boolean [] findTrojan = new boolean[TEST_CODE_NUM]; // 악성코드 찾았는지 판단해주는 변수
    int [] nextTestStartIdx_spyware = new int[TEST_CODE_NUM]; // 악성코드 일치하는 게 끊겼을 때 다음에 어디부터 검사하면 되는지 알려주는 인덱스
    int [] nextTestStartIdx_trojan = new int[TEST_CODE_NUM]; // 악성코드 일치하는 게 끊겼을 때 다음에 어디부터 검사하면 되는지 알려주는 인덱스
    public MalwareTestSystem() {
        // 악성코드 읽어오기
        readMalwareFile(spywareFile, spywareCode);
        readMalwareFile(trojanFile, trojanCode);
        for(int i=0; i<TEST_CODE_NUM; i++) {
            findSpyware[i] = false;
            findTrojan[i] = false;
        }
        for(int i=0; i<TEST_CODE_NUM; i++) {
            nextTestStartIdx_spyware[i] = 0;
            nextTestStartIdx_trojan[i] = 0;
        }
        // 이 부분은 스레드가 해야됨 코드 옮길거임
        for(int i=1; i<=TEST_CODE_NUM; i++) {
            testCode[i-1] = new String("");
            readTestFile(i);
        }
        // 이 부분도 스레드가
        for(int i=1; i<=TEST_CODE_NUM; i++) {
            searchMalwareCode(i, testCode[i-1]);
        }
    }
    public void readTestFile(int testNum){
        String filePath = "./inputText/Files/File" + testNum + ".txt";
        FileReader fileReader;
        try {
            fileReader = new FileReader(filePath);
            int c;
            while((c = fileReader.read()) != -1) {
                testCode[testNum-1] += Character.toString((char)c);
            }
            System.out.println(testCode[testNum-1]);
            fileReader.close();
        } catch (IOException e) {
            System.out.println("입출력 오류");
        }
    }
    public void readMalwareFile(File file, String malwareCode) {
        FileReader fileReader;
        try {
            fileReader = new FileReader(file);
            int c;
            while(((c = fileReader.read()) != -1)) {
                malwareCode += Character.toString((char)c);
            }
            System.out.println(malwareCode);
            fileReader.close();
        } catch (IOException e) {
            System.out.println("입출력 오류");
        }
    }
    public void searchMalwareCode(int testNum, String presentTestCode) {
        String subTestCodeSpyware;
        String subTestCodeTrojan;
        String subSpyware;
        String subTrojan;

        // presentTestCode를 검사할 때 악성코드 전체를 통째로 검사하는 부분의 마지막 인덱스
        int testAllSpywareIdx = presentTestCode.length() - spywareCode.length();
        int testAllTrojanIdx = presentTestCode.length() - trojanCode.length();
        for(int i=0; i < presentTestCode.length(); i++){
            // 악성코드를 못찾았을 때만 검사 실행
            if(findSpyware[i-1] == false) {
                // 저번 검사에서 악성코드 일치한 게 끊겼을 때 그게 이어지는지 검사
                if(i == 0 && nextTestStartIdx_spyware[testNum-1] != 0) {
                    subTestCodeSpyware = presentTestCode.substring(0, spywareCode.length());
                    subSpyware = spywareCode.substring(nextTestStartIdx_spyware[testNum-1]);
                    if(subTestCodeSpyware.equals(subSpyware)) {
                        findSpyware[testNum-1] = true;
                    }
                }
                // 통째로 검사
                if(i <= testAllSpywareIdx){
                    subTestCodeSpyware = presentTestCode.substring(i, i+spywareCode.length());
                    if(subTestCodeSpyware.equals(spywareCode)){
                        findSpyware[testNum-1] = true;
                    }
                } else { // 악성코드를 부분적으로 잘라서 검사
                    subTestCodeSpyware = presentTestCode.substring(i); // 검사 코드 남은 부분만 잘라오기
                    subSpyware = spywareCode.substring(0, presentTestCode.length()-i); // 악성코드는 비교할 앞부분 자르기
                    if(subTestCodeSpyware.equals(subSpyware)){
                        nextTestStartIdx_spyware[testNum-1] = presentTestCode.length()-i;
                    }
                }
            }
            // 악성코드를 못찾았을 때만 검사 실행
            if(findTrojan[i-1] == false) {
                // 저번 검사에서 악성코드 일치한 게 끊겼을 때 그게 이어지는지 검사
                if(i == 0 && nextTestStartIdx_trojan[testNum-1] != 0) {
                    subTestCodeTrojan = presentTestCode.substring(0, trojanCode.length());
                    subTrojan = trojanCode.substring(nextTestStartIdx_trojan[testNum-1]);
                    if(subTestCodeTrojan.equals(subTrojan)) {
                        findTrojan[testNum-1] = true;
                    }
                }
                // 통째로 검사
                if(i <= testAllTrojanIdx){
                    subTestCodeTrojan = presentTestCode.substring(i, i+trojanCode.length());
                    if(subTestCodeTrojan.equals(trojanCode)){
                        findTrojan[testNum-1] = true;
                    }
                } else { // 악성코드를 부분적으로 잘라서 검사
                    subTestCodeTrojan = presentTestCode.substring((i)); // 남은 부분만 잘라오기
                    subTrojan = trojanCode.substring(0, presentTestCode.length()-i); // 악성코드는 비교할 앞부분 자르기
                    if(subTestCodeTrojan.equals(subTrojan)){
                        nextTestStartIdx_trojan[testNum-1] = presentTestCode.length()-i;
                    }
                }
            }
        }


    }
}
